declare const any: any;
declare function use(...args: any[]): void;

// Special handling of enum members
{
    {
        enum E {
            A,
            B,
            ~ [enummembernevercreated]
            C,
            ~ [unused]
        }

        function f(e: E) {
            switch (e) { //TODO: similar test with 'if' and '==='
                case E.A:
                case E.B:
                    return true;
                default:
                    return false;
            }
        }
        use(f(E.A));
    }

    {
        // Internal uses of an enum member don't count.
        enum Flags {
            A = 1 << 0,
            ~ [unused]
            B = 1 << 1,
            All = A | B,
        }
        use(Flags.B, Flags.All);
    }
}

// Catches never-used symbol of any kind
{
    type T = number;
         ~ [noread]
}

{
    function f() { return 0; }
             ~ [sideeffectonly]
    f();
}
{
    function f() {}
    f();
}

// Catches 'let' that could be 'const', just like for properties that could be 'readonly'.
{
    let x = 0;
        ~ [const]
    use(x);
}

{
    class C {
        readonly p!: number;
                 ~ [nocreate]
    }
    use(new C().p);
}

// Casting indirectly creates properties
{
    use((<{ readonly x: number }> any).x);
    use((any as { x: number }).x);
                  ~ [readonly]
}

//// Tests for indirect assignment of properties
{
    // Assigning a type to itself doesn't count.
    {
        interface I { x: number; }
                      ~ [unused]
        function _(i: I) { return i; }
    }

    // 'any' indirectly assigns to all properties
    {
        function f(p: { readonly x: number }) {
            use(p.x);
        }
        f(any);
    }

    // Type predicate indirectly creates properties
    {
        function magic(o: {}): o is { readonly x: string } {
            return true;
        }
        if (magic(any)) {
            use(any.x);
        }
    }

    {
        function f(p: { readonly x?: number, readonly y?: number }) {
                                                      ~ [nocreate]
            use(p.x, p.y);
        }
        // Deliberately *don't* give this a contextual type, so these isn't directly a creation of the 'x' property above.
        const o = { x: 0 };
        f(o);
    }

    // Same as above but with some other types in the way
    {
        function f(p: ReadonlyArray<{ readonly x: number, readonly y?: number } | number> | number) {
                                                                   ~ [nocreate]
            if (typeof p !== "number") {
                const z = p[0];
                if (typeof z !== "number") {
                    use(z.x, z.y);
                }
            }
        }
        const o = [{ x: 1 }];
        f(o);
    }

    // Can't use a ReadonlyArray if we need to assign to mutable array type
    {
        class C {
            constructor(readonly x: string[]) {}
        }
        interface I {
            readonly x: string[];
        }
        const i: I = new C([]);
        i.x.push("");
        use(i.x);
    }
}

// Privacy tests
{
    class C {
        constructor(readonly x: number) {}
                             ~ [private]
	    m() {
	        use(this.x);
	    }
	}
	new C(0).m();
}

// Prefer readonly collection types
{
    // Exception for rest parameters, which can't be ReadonlyArray
    {
        function _(x: number[], ...y: number[]) {
                      ~~~~~~~~ [readonlyarray]
            return [...x, ...y];
        }
    }

    // Uses inferred type if no type annotation -- handles unions too.
    {
        class C {
            readonly x = any ? [] : 2;
                     ~ [readonlyarray]
        }
        const { x } = new C();
        if (typeof x !== "number") {
            use(x.length);
        }
    }

    {
        // Does not complain on implicitly-typed local variables
        const x = [0];
        use(x);
    }

    {
        // Assignment to 'any' still considered readonly
        const x: number[] = [];
                 ~~~~~~~~ [readonlyarray]
        const _: any = x;
    }

    // Works on Set and Map
    {
        const s: Set<number> = new Set();
                 ~~~~~~~~~~~ [readonlyset]
        s.has(0);
        const m: Map<number, number> = new Map();
                 ~~~~~~~~~~~~~~~~~~~ [readonlymap]
        m.get(0);
    }
}
// Does complain at top-level
const readonlyArray = [0];
      ~~~~~~~~~~~~~ [readonlyarray]
use(readonlyArray);

//// Detects collections that are written to but not read from.
{
    // "push" and "unshift" just return the length, so this isn't really using the collection (could just use a counter).
    {
        const x: number[] = [];
              ~ [pushonly]
        use(x.push(0));
        use(x.unshift());
    }

    // Element accesses make it not readonly
    {
        function _assignTo(x: number[]) {
            x[0] = 1;
        }
        let _: any;
        function _assignFrom(x: number[]) {
                                ~~~~~~~~ [readonlyarray]
            _ = x[0];
        }
        function _delete(x: number[]) {
            delete x[0];
        }
    }

    // Works on properties too.
    {
        class C {
            m = new Map<number, number>();
            ~ [pushonly]
        }
        const c = new C();
        c.m.set(0, 0);
    }

    // If we the collection is initialized to an alias, it's *not* unused.
    {
        const x: number[] = any;
        x.push(0);
    }

    // Counterexamples: "pop" and "shift" and "splice" return useful data.
    {
        const x: number[] = [];
        use(x.pop());
    }
    {
        const x: number[] = [];
        use(x.shift());
    }
    {
        const x: number[] = [];
        use(x.splice(0, 3));
    }

    // Some methods return the collection, so we must consider what happens after that.
    {
        const x: number[] = [];
              ~ [pushonly]
        x.sort();
    }
    {
        const x: number[] = [];
        use(x.sort());
    }
    {
        const x: number[] = [];
        use(x.sort().pop());
    }

    // Also works on Set/Map
    {
        const x = new Set();
              ~ [pushonly]
        x.add(1);
        x.delete(1);
    }
    {
        const x = new Set();
        x.add(1);
        use(x.delete(1)); // 'delete' tells us whether it was in the set, so the set content is used.
    }

    // Detects chaining
    {
        const s = new Set();
              ~ [pushonly]
        s.add(1).delete(1);
    }
    {
        const s = new Set();
        use(s.add(1).delete(1));
    }
}

// Anything in `@deprecated` is ignored
{
    /** @deprecated */
    interface I {
        x: {
            y: number[];
        }
    }
    interface J {
              ~ [noread]
        /** @deprecated */
        x: number[];
    }
}
// Anything starting with `_` is ignored
{
    const _x = 0;
}

[enummembernevercreated]: Enum member is compared against, but analysis found no cases of something being given this value.
[const]: Analysis found no mutable uses of this variable; use `const`.
[unused]: Analysis found no uses of this symbol.
[private]: Analysis found no public uses; this should be private.
[pushonly]: This collection is created and filled with values, but never read from.
[sideeffectonly]: This function is used for its side effect, but the return value is never used.
[nocreate]: Analysis found places where this is read, but found no places where it is given a value.
[noread]: This symbol is given a value, but analysis found no reads. This is likely dead code.
[readonly]: Analysis found no writes to this property; mark it as `readonly`.
[readonlyarray]: Analysis indicates this could be a ReadonlyArray.
[readonlyset]: Analysis indicates this could be a ReadonlySet.
[readonlymap]: Analysis indicates this could be a ReadonlyMap.

