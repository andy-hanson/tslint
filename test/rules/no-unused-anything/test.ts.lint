declare const any: any;
declare function use(...args: any[]): void;

{
    function f() { return 0; }
             ~ [sideeffectonly]
    f();
}
{
    function f() {}
    f();
}

declare function use(...args: any[]): void;
{
    class C {
        readonly p!: number;
                 ~ [nocreate]
    }
    use(new C().p);
}


//// Detects collections that are written to but not read from.
{
    // "push" and "unshift" just return the length, so this isn't really using the collection (could just use a counter).
    {
        const x: number[] = [];
              ~ [pushonly]
        use(x.push(0));
        use(x.unshift());
    }

    // Counterexamples: "pop" and "shift" and "splice" return useful data.
    {
        const x: number[] = [];
        use(x.pop());
    }
    {
        const x: number[] = [];
        use(x.shift());
    }
    {
        const x: number[] = [];
        use(x.splice(0, 3));
    }

    // Some methods return the collection, so we must consider what happens after that.
    {
        const x: number[] = [];
              ~ [pushonly]
        x.sort();
    }
    {
        const x: number[] = [];
        use(x.sort());
    }
    {
        const x: number[] = [];
        use(x.sort().pop());
    }

    // Also works on Set/Map
    {
        const x = new Set();
              ~ [pushonly]
        x.add(1);
        x.delete(1);
    }
    {
        const x = new Set();
        x.add(1);
        use(x.delete(1)); // 'delete' tells us whether it was in the set, so the set content is used.
    }

    // Detects chaining
    {
        const s = new Set();
              ~ [pushonly]
        s.add(1).delete(1);
    }
    {
        const s = new Set();
        use(s.add(1).delete(1));
    }
}

// Casting indirectly creates properties
{
    use((<{ readonly x: number }> any).x);
    use((any as { x: number }).x);
                  ~ [readonly]
}

//// Tests for indirect assignment of properties
{
    // 'any' indirectly assigns to all properties
    {
        function f(p: { readonly x: number }) {
            use(p.x);
        }
        f(any);
    }

    // Type predicate indirectly creates properties
    {
        function magic(o: {}): o is { readonly x: string } {
            return true;
        }
        if (magic(any)) {
            use(any.x);
        }
    }

    {
        function f(p: { readonly x?: number, readonly y?: number }) {
                                                      ~ [nocreate]
            use(p.x, p.y);
        }
        // Deliberately *don't* give this a contextual type, so these isn't directly a creation of the 'x' property above.
        const o = { x: 0 };
        f(o);
    }

    // Same as above but with some other types in the way
    {
        function f(p: ReadonlyArray<{ readonly x: number, readonly y?: number } | number> | number) {
                                                                   ~ [nocreate]
            if (typeof p !== "number") {
                const z = p[0];
                if (typeof z !== "number") {
                    use(z.x, z.y);
                }
            }
        }
        const o = [{ x: 1 }];
        f(o);
    }

    // Means we can't use a ReadonlyArray if we need to assign to mutable array type
    {
        class C {
            constructor(readonly x: string[]) {}

        }
        interface I {
            readonly x: string[];
        }
        const i: I = new C([]);
        i.x.push("");
        use(i.x);
    }
}

// Privacy tests
{
    class C {
        constructor(readonly x: number) {}
                             ~ [private]
	    m() {
	        use(this.x);
	    }
	}
	new C(0).m();
}

[private]: Analysis found no public uses; this should be private.
[pushonly]: This collection is created and filled with values, but never read from.
[sideeffectonly]: This function is used for its side effect, but the return value is never used.
[nocreate]: Analysis found places where this is read, but found no places where it is given a value.
[noread]: This symbol is given a value, but analysis found no reads. This is likely dead code.
[readonly]: Analysis found no writes to this property; mark it as `readonly`.
